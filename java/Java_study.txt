

1.输入输出都是特定名字空间的函数System.out.println();
  另外，没有特殊的像C语言的%d,%c这样的表达方式限制

2.所有的一切函数都包含在类中，
运行的也是某一个类名
源文件中不能有两个public的类，如果有两个public的类必须放在两个文件中

path和classpath分别用来设定java命令和javac命令的查找，
区别是前者先找当前目录，再path；后者是只与classpath中查找类，与是否在当前目录无关


3.Arrays.sort命令
  System.arraycopy()函数拷贝数组
  数组还有length这样的自带功能

4.数组的理解不一样（多维）
  二维数组实际上有一个数组，并且这个数组的每个元素也是一个数组，并且这些元素的数组长度可以不同
int[][] xx={};

5.继承关系感觉没有公有继承，私有继承，
Java是extends关键字来表达
只支持单继承，不允许多继承；可以有多层继承。
Super子类可以显示调用父类的构造函数（如果一个类希望被继承，最好还要定义个
无参数的构造函数）

6.this已经成了类自己的代名词，非指针（Java已经没有指针）
构造函数如果有this，则该类将调用其他构造函数（包含super来调用父类构造函数）
 this调用和super()调用不能同时出现在构造函数，并且只能出现在首部。
这里的this是指“this函数”，而不是this类对象


7.Java中子类自动覆盖父类的同名成员函数，
如果想调用父类，在其前加上super 

8.final“最后版本”用来形容类，成员函数和成员变量
成员变量若为final，必须初始定义化或者在所有构造函数中赋值

public static final 联合使用，用途特别，定义一个常量????

9.如果一个类的成员函数有throws抛异常，(可以多级传递出去异常)
？？？throw有什么区别？函数后？
//throws是指该函数有可能异常抛出，紧跟函数名后面
  throw是有可能抛出异常的函数里有确确实实的特定异常抛出

那么调用该成员函数的类必须有try....catch机制来保护
Exception ex ///ex.getMessage
此机制跟C++相类似


10.抽象类用关键字abstract来形容成员函数(相当于C++中的虚基类)
但是C＋＋的抽象类是以virtual fun()=0;形式表达的

 Java中整个类可以为抽象类，不能被实例化，同样C++抽象类也是如此
不是抽象类的所有方法都是抽象的

11.new是一个对象的声明，区别于C++语言，不能理解为指针

12.C++版的catch(...)和Java版的catch(Exception e)意义差不多

13.finally作为捕获异常的最后一个出口（防止try语句中有return语句提前返回）
感觉C++没有类似的语句

14.System.exit(0)提前退出整个程序

15.子类不能把父类的同名成员访问权限不能更弱
可以将private变成public的访问权限，不能将public的访问权限变成private权限

16.子类中覆盖的成员函数抛出的异常只能比父类中的少，不能比父类中的多，
也就是子类中的同名成员函数抛出的异常不能另外添加，可以没有。

17.package相当于C++语言的名字空间
package org.t13; 这个声名表示：在该package下面的类必须在以前的基础上创建多级同名目录，然后再
来安放这些文件

18.包中的类相互调用不用加包名，但是包间则要加 

19.一个java文件编译出多个类文件，在包的相应目录里同时生成多个class文件，则这个时候哪一个是main主要编译出结果的
文件还是难题????

生成可执行jar包： 
编译的class文件中必须有main入口函数的类方能生成可执行jar包，如：
public static void main(String[] args)

文件名体现是类名，而目录名体现包名

javac -d . *.java可以在该当前目录下创建和包名对应的文件夹（这也是SUN公司的疏漏）

20.带有包名的类，运行时即使在包名对应的目录下，也不能直接用类名来调java执行class，
这个类名必须带有完整的包名前缀

执行java该命令的时候也有讲究，要在外层执行，不能到了内存，再进入带包名的目录下就找不到了；
另外，不要自己人为建一个多层文件夹，把class文件放进去，就以为有了一个包名。
也就是说包名不能缺省

21.set classpath可以设置为jar包名，并且以jar包解压并当作一个目录名
只有类属性为public的才可以调用；
不同包名之间的类成员函数调用，
如果每次都要将包名各目录都罗列一番，显然有些繁杂，
因此就可以将被调用的包名用import；例如：import org.it315.*;
这有点像c++中的include *.h语句

22.父包和子包之间没有任何关系，这两者之间，如果有类相互调用，也必须把包名带上；
import导入父包，还有必要导入子包，可以有多个import语句；
package必须只有一句

23.JDK系统自带的包有 java.lang.*

24.类本身也有访问权限，这与C++有很大区别

另外，类成员函数的访问权限分为4种：私有，缺省，保护，公有，比C++多了一种缺省类型（也称包类型，只能在包内调用）

25.有点疑问
子类分为同一包中的子类和不同包中的子类，
父类为default，不能被继承。
如果父内的成员函数为default，即使子类和父类在一个包内，也是无法访问该父类的成员函数的。

26.疑问？
一个Java文件一般就是一个包单位？
换句话说，一个java文件有很多类，这些类都在同一个包内，在这个java文件的开头就适合放一个包名。

程序中如果有package语句，该语句一定是源文件中的第一条可执行语句，它的前面只能有注释或空行。另外，一个文件中最多只能有一条package语句。
包的名字有层次关系，各层之间以点分隔。包层次必须与Java开发系统的文件系统结构相同。通常包名中全部用小写字母，这与类名以大写字母开头，且各字的首字母亦大写的命名约定有所不同。
当使用包说明时，程序中无需再引用(import)同一个包或该包的任何元素。import语句只用来将其他包中的类引入当前名字空间中。而当前包总是处于当前名字空间中。
如果文件声明如下：
package java.awt.image
则此文件必须存放在Windows的java\awt\image目录下或unix的java/awt/image目录下。
